<!DOCTYPE html>
<html manifest="./manifest.appcache">
<head>
<meta charset="UTF-8" />
<title>AltJSDoIt 0.10.35 epsilon</title>
<link rel='source' href='http://goo.gl/m8jE3p' />


<style>
header#menu nav input[type="radio"] {
  display: none;
}
header#menu nav input[type="radio"]:checked + label {
  color: #2d2d2d;
  font-weight: bold;
}
header#menu nav label {
  padding: 0px 10px;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  color: #4b4b4b;
  text-transform: capitalize;
  font-size: 1em;
  line-height: 1.75;
}
header#menu nav label:nth-of-type(1) {
  border-left: 3px solid #32d2fa;
}
header#menu nav label:nth-of-type(2) {
  border-left: 3px solid #0e90d2;
}
header#menu nav label:nth-of-type(3) {
  border-left: 3px solid #8058a5;
}
header#menu nav label:nth-of-type(4) {
  border-left: 3px solid #5eb95e;
}
header#menu nav label:nth-of-type(5) {
  border-left: 3px solid #dd514c;
}
header#menu nav label:nth-of-type(6) {
  border-left: 3px solid #f37b1d;
}
header#menu nav label:nth-of-type(7) {
  border-left: 3px solid #fad232;
}
html,
body,
warpper {
  height: 100%;
}
#main {
  position: absolute;
  height: 100%;
  width: 100%;
}
#main > * {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  -moz-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
#main > #box-config {
  padding: 1em;
}
#main > #box-editor {
  width: 100%;
  height: 100%;
}
#main > #box-editor > #box-editor-textarea {
  width: 100%;
  height: 100%;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  -moz-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
#main > #box-sandbox {
  width: 100%;
  height: 100%;
}
#main > #box-sandbox > #box-sandbox-iframe {
  margin: 0;
  border: none;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  -moz-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
.CodeMirror,
textarea,
code {
  font-family: 'Menlo', 'Monaco', 'Andale Mono', 'lucida console', 'Courier New', 'monospace' !important;
}
</style>

</head>
<body>

<meta name="Description" content="altjsdoit - A Simple WebApp Editor - "/>
<meta name="Keywords" content="JavaScript,CoffeeScript,HTML5,CSS,altjs,less,stylus,jade"/>
<meta name="viewport" content="width=device-width user-scalable=no,initial-scale=1,maximum-scale=1"/>
<base href="https://altjsdoit.github.io/"/>
<link rel="apple-touch-icon" href="./icon-128.png"/>
<link rel="stylesheet" href="./thirdparty/codemirror/codemirror.css"/>
<link rel="stylesheet" href="./thirdparty/codemirror/theme/solarized.css"/>
<link rel="stylesheet" href="./thirdparty/codemirror/addon/dialog/dialog.css"/>
<link rel="stylesheet" href="./thirdparty/pure/pure-min.css"/>
<script src="./thirdparty/es6-shim/es6-shim.min.js"></script>
<script src="./thirdparty/zepto/zepto.min.js"></script>
<script src="./thirdparty/vue/vue.min.js"></script>
<script src="./thirdparty/jszip/jszip.min.js"></script>
<script src="./thirdparty/webmodule/WMURLShortener.min.js"></script>
<script src="./thirdparty/codemirror/codemirror.min.js"></script>
<script src="./thirdparty/codemirror/addon/search/searchcursor.js"></script>
<script src="./thirdparty/codemirror/addon/search/search.js"></script>
<script src="./thirdparty/codemirror/addon/dialog/dialog.js"></script>
<script src="./thirdparty/codemirror/addon/edit/matchbrackets.js"></script>
<script src="./thirdparty/codemirror/addon/edit/closebrackets.js"></script>
<script src="./thirdparty/codemirror/mode/javascript/javascript.js"></script>
<script src="./thirdparty/codemirror/mode/coffeescript/coffeescript.js"></script>
<script src="./thirdparty/codemirror/mode/haskell/haskell.js"></script>
<script src="./thirdparty/codemirror/mode/xml/xml.js"></script>
<script src="./thirdparty/codemirror/mode/jade/jade.js"></script>
<script src="./thirdparty/codemirror/mode/css/css.js"></script>
<script src="./thirdparty/codemirror/mode/scheme/scheme.js"></script>
<script src="./thirdparty/codemirror/mode/commonlisp/commonlisp.js"></script>
<script src="./thirdparty/codemirror/mode/clojure/clojure.js"></script>
<script src="./thirdparty/codemirror/mode/livescript/livescript.js"></script>
<script src="./thirdparty/codemirror/mode/sml/sml-codemirror-mode.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<div id="wrapper">
  <header id="menu" v-on="change: change" class="home-menu pure-menu pure-menu-open pure-menu-horizontal pure-menu-fixed">
    <nav>
      <input type="radio" name="tab" id="tab0" value="config" checked="checked"/>
      <label for="tab0">Altjsdoit</label>
      <input type="radio" name="tab" id="tab1" value="altjs"/>
      <label for="tab1">{{altjs}}</label>
      <input type="radio" name="tab" id="tab2" value="althtml"/>
      <label for="tab2">{{althtml}}</label>
      <input type="radio" name="tab" id="tab3" value="altcss"/>
      <label for="tab3">{{altcss}}</label>
      <input type="radio" name="tab" id="tab4" value="compile"/>
      <label for="tab4">Compile</label>
      <input type="radio" name="tab" id="tab5" value="sandbox"/>
      <label for="tab5">Run</label>
    </nav>
  </header>
  <section id="main">
    <section id="box-config" v-on="change: change">
      <form class="pure-form pure-form-stacked">
        <fieldset>
          <legend>Project</legend>
          <label>Title:
            <input v-model="title" type="text" value="" placeholder="no title"/>
          </label>
          <label>URL:
            <input id="config-project-url" type="url" value="" placeholder=""/>
          </label>
          <input type="button" value="Save" v-on="click: save" class="pure-button pure-button-primary"/>&nbsp;<a target="_blank" href="/" class="pure-button">New Project</a>&nbsp;<span id="config-project-twitter"></span>
        </fieldset>
        <fieldset>
          <legend>Compilers</legend>
          <label>altjs:
            <select v-model="altjs" data-config="altjs">
              <option value="JavaScript" selected="selected">JavaScript</option>
              <option value="CoffeeScript">CoffeeScript</option>
              <option value="TypeScript">TypeScript</option>
              <option value="Traceur">Traceur</option>
              <option value="LiveScript">LiveScript</option>
              <option value="PureScript">PureScript</option>
              <option value="GorillaScript">GorillaScript</option>
              <option value="Roy">Roy</option>
              <option value="BiwaScheme">BiwaScheme</option>
              <option value="Wisp">Wisp</option>
              <option value="LispyScript">LispyScript</option>
              <option value="BlackCoffee">BlackCoffee</option>
            </select>
          </label>
          <label>althtml:
            <select v-model="althtml" data-config="althtml">
              <option value="HTML" selected="selected">HTML</option>
              <option value="Jade">Jade</option>
            </select>
          </label>
          <label>altcss:
            <select v-model="altcss" data-config="altcss">
              <option value="CSS" selected="selected">CSS</option>
              <option value="Stylus">Stylus</option>
              <option value="LESS">LESS</option>
            </select>
          </label>
        </fieldset>
        <fieldset>
          <legend>Libraries</legend>
          <label>Firebug-Lite(1.4.0):
            <input v-model="enableFirebugLite" type="checkbox"/>
          </label>
          <label>Zepto(1.1.3):
            <input v-model="enableZepto" type="checkbox"/>
          </label>
          <label>jQuery(2.1.1):
            <input v-model="enableJQuery" type="checkbox"/>
          </label>
          <label>Underscore.js(1.6.0):
            <input v-model="enableUnderscore" type="checkbox"/>
          </label>
          <label>Backbone.js(1.1.2):
            <input v-model="enableBackbone" type="checkbox"/>
          </label>
          <label>es6-shim(0.11.0):
            <input v-model="enableES6shim" type="checkbox"/>
          </label>
          <label>Processing.js(1.4.8):
            <input v-model="enableProcessing" type="checkbox"/>
          </label>
          <label>Chart.js(0.2.0):
            <input v-model="enableChartjs" type="checkbox"/>
          </label>
          <label>mathjs(0.23.0):
            <input v-model="enableMathjs" type="checkbox"/>
          </label>
          <label>pure(0.5.0):
            <input v-model="enablePure" type="checkbox"/>
          </label>
        </fieldset>
        <fieldset>
          <legend>Debug</legend>
          <label>use CodeMirror:
            <input v-model="enableCodeMirror" type="checkbox" checked="checked"/>
          </label>
          <label>use blobCache:
            <input v-model="enableBlobCache" type="checkbox"/>
          </label>
          <label>iframe type:
            <select v-model="iframeType">
              <option value="message">message</option>
              <option value="blob" selected="selected">objectURL</option>
              <option value="srcdoc">srcdoc</option>
              <option value="base64">dataURI</option>
            </select>
          </label>
        </fieldset>
        <fieldset>
          <legend>About</legend>
          <p>
            <script>document.write($("title").html());</script>
          </p>
          <p><a target="_blank" href="https://github.com/altjsdoit/" class="pure-button">Github</a>&nbsp;<a target="_blank" href="https://twitter.com/search?q=%23altjsdoit" class="pure-button">Twitter</a></p>
        </fieldset>
      </form>
    </section>
    <section id="box-editor" style="display:none;">
      <textarea id="box-editor-textarea"></textarea>
    </section>
    <section id="box-sandbox" style="display:none;">
      <iframe id="box-sandbox-iframe"></iframe>
    </section>
  </section>
</div>
<script>
var ACC, Compiler, Configure, Editor, Sandbox, initTwitter, main;

window.URL = window.URL || window.webkitURL || window.mozURL;

main = function() {
  var $config, $editor, $pages, $sandbox, altcss, althtml, altjs, compile, compiler, config, configure, editor, sandbox, twitElm, urlElm, _ref;
  window.applicationCache.addEventListener('updateready', function(ev) {});
  if (window.applicationCache.status === window.applicationCache.UPDATEREADY) {
    window.applicationCache.swapCache();
    if (confirm('A new version of this site is available. Save and load it?')) {
      configure.save(editor.get());
      location.reload();
    }
  }
  config = {
    timestamp: Date.now()
  };
  configure = new Configure(config);
  _ref = configure.load(), altjs = _ref.altjs, althtml = _ref.althtml, altcss = _ref.altcss;
  console.dir(JSON.parse(JSON.stringify(config)));
  $pages = $("#main > *");
  $config = $("#box-config");
  $editor = $("#box-editor");
  $sandbox = $("#box-sandbox");
  compile = function(callback) {
    var source, url;
    source = editor.get();
    url = configure.save(source);
    return compiler.compile(url, source, callback);
  };
  new Vue({
    el: '#menu',
    data: config,
    methods: {
      change: function(ev) {
        if (ev.target.name === "tab") {
          configure.save(editor.get());
          $pages.hide();
          sandbox.stop();
          switch (ev.target.value) {
            case "config":
              return $config.show();
            case "altjs":
              $editor.show();
              return editor.tab("altjs");
            case "althtml":
              $editor.show();
              return editor.tab("althtml");
            case "altcss":
              $editor.show();
              return editor.tab("altcss");
            case "compile":
              $editor.show();
              editor.tab("compile");
              editor.set({
                compile: "compiling..."
              });
              return compile(function(err, html) {
                return editor.set({
                  compile: html
                });
              });
            case "sandbox":
              $sandbox.show();
              sandbox.run("<p>compiling...</p>");
              return compile(function(err, html) {
                sandbox.stop();
                return setTimeout(function() {
                  return sandbox.run(html);
                });
              });
          }
        }
      }
    }
  });
  urlElm = document.getElementById("config-project-url");
  twitElm = document.getElementById("config-project-twitter");
  new Vue({
    el: '#box-config',
    data: config,
    methods: {
      save: function(ev) {
        var url;
        url = configure.save(editor.get());
        urlElm.value = url;
        return new WMURLShortener().shorten(url, function(err, shortUrl) {
          if (!!err) {
            return $(twitElm).html("network error");
          }
          urlElm.value = shortUrl;
          return initTwitter(twitElm, config, shortUrl);
        });
      },
      change: function(ev) {
        return compiler.change();
      }
    }
  });
  editor = new Editor(document.getElementById("box-editor-textarea"), config);
  editor.set({
    altjs: altjs,
    althtml: althtml,
    altcss: altcss
  });
  editor.onsave = function() {
    return configure.save(editor.get());
  };
  editor.onrun = function() {
    return compile(function(err, html) {
      sandbox.stop();
      return setTimeout(function() {
        return sandbox.run(html);
      });
    });
  };
  sandbox = new Sandbox(document.getElementById("box-sandbox-iframe"), config);
  return compiler = new Compiler(config);
};

(function() {
  var $main, $nav, $window;
  $window = $(window);
  $nav = $("#menu>nav");
  $main = $("#main");
  $window.on("beforeunload", function(ev) {
    var msg;
    msg = "Are you sure you want to leave?";
    return (ev || window.event).returnValue = msg;
  });
  $window.resize(function() {
    var height;
    height = $nav.height();
    return $main.css({
      "top": height + "px",
      "height": ($window.height() - height) + "px"
    });
  });
  return $window.resize();
})();

initTwitter = function(elm, config, shortUrl) {
  $(elm).html($("<a />").attr({
    "href": "https://twitter.com/share",
    "class": "twitter-share-button",
    "data-size": "large",
    "data-text": "'" + config.title + "'",
    "data-url": shortUrl,
    "data-hashtags": "altjsdoit",
    "data-count": "none",
    "data-lang": "en"
  }).html("Tweet"));
  return twttr.widgets.load();
};

Configure = (function() {
  var decodeURIQuery, encodeURIQuery, pwd, unzipDataURI, zipDataURI;

  pwd = location.protocol + '//' + location.hostname + location.port + location.pathname;

  zipDataURI = function(dic) {
    var key, val, zip;
    zip = new JSZip();
    for (key in dic) {
      val = dic[key];
      zip.file(key, val);
    }
    return zip.generate({
      compression: "DEFLATE"
    });
  };

  unzipDataURI = function(base64) {
    var files, hash, key, val, zip;
    zip = new JSZip();
    files = zip.load(base64, {
      base64: true
    }).files;
    hash = {};
    for (key in files) {
      val = files[key];
      hash[key] = zip.file(key).asText();
    }
    return hash;
  };

  encodeURIQuery = function(dic) {
    var key, val;
    return ((function() {
      var _results;
      _results = [];
      for (key in dic) {
        val = dic[key];
        _results.push(key + "=" + encodeURIComponent(val));
      }
      return _results;
    })()).join("&");
  };

  decodeURIQuery = function(query) {
    return query.split("&").map(function(a) {
      var b;
      b = a.split("=");
      return [b[0], b.slice(1).join("=")];
    }).reduce((function(a, b) {
      a[b[0]] = decodeURIComponent(b[1]);
      return a;
    }), {});
  };

  function Configure(config) {
    this.config = config;
  }

  Configure.prototype.load = function() {
    var key, markup, script, style, zip, __config, _config, _ref;
    zip = decodeURIQuery(location.hash.slice(1)).zip;
    if (zip != null) {
      _ref = unzipDataURI(zip), _config = _ref.config, script = _ref.script, markup = _ref.markup, style = _ref.style;
      __config = JSON.parse(_config);
      if (!!__config) {
        for (key in __config) {
          this.config[key] = __config[key];
        }
      }
    }
    return {
      altjs: script || null,
      althtml: markup || null,
      altcss: style || null
    };
  };

  Configure.prototype.save = function(_arg) {
    var altcss, althtml, altjs, url, _config;
    altjs = _arg.altjs, althtml = _arg.althtml, altcss = _arg.altcss;
    this.config.timestamp = Date.now();
    _config = {
      script: altjs,
      markup: althtml,
      style: altcss,
      config: JSON.stringify(this.config)
    };
    $("title").html("" + this.config.title + " - " + (new Date(this.config.timestamp)) + " - altjsdo.it");
    url = pwd + "#" + encodeURIQuery({
      zip: zipDataURI(_config)
    });
    if (location.protocol !== "blob:") {
      history.pushState(null, null, url);
    }
    return url;
  };

  return Configure;

})();

Editor = (function() {
  function Editor(textarea, config) {
    var $radios, changeTab;
    this.textarea = textarea;
    this.config = config;
    $radios = $("#menu input[type=radio]");
    changeTab = function(selector) {
      return $(selector).click();
    };
    this.option = {
      tabMode: "indent",
      tabSize: 2,
      theme: 'solarized dark',
      autoCloseTags: true,
      lineNumbers: true,
      matchBrackets: true,
      autoCloseBrackets: true,
      showCursorWhenSelecting: true,
      extraKeys: {
        "Tab": function(cm) {
          return CodeMirror.commands[(cm.getSelection().length ? "indentMore" : "insertSoftTab")](cm);
        },
        "Shift-Tab": "indentLess",
        "Cmd-R": (function(_this) {
          return function(cm) {
            return _this.onrun();
          };
        })(this),
        "Ctrl-R": (function(_this) {
          return function(cm) {
            return _this.onrun();
          };
        })(this),
        "Cmd-S": (function(_this) {
          return function(cm) {
            return _this.onsave();
          };
        })(this),
        "Ctrl-S": (function(_this) {
          return function(cm) {
            return _this.onsave();
          };
        })(this),
        "Cmd-1": (function(_this) {
          return function(cm) {
            return changeTab("#tab1");
          };
        })(this),
        "Ctrl-1": (function(_this) {
          return function(cm) {
            return changeTab("#tab1");
          };
        })(this),
        "Cmd-2": (function(_this) {
          return function(cm) {
            return changeTab("#tab2");
          };
        })(this),
        "Ctrl-2": (function(_this) {
          return function(cm) {
            return changeTab("#tab2");
          };
        })(this),
        "Cmd-3": (function(_this) {
          return function(cm) {
            return changeTab("#tab3");
          };
        })(this),
        "Ctrl-3": (function(_this) {
          return function(cm) {
            return changeTab("#tab3");
          };
        })(this),
        "Cmd-4": (function(_this) {
          return function(cm) {
            return changeTab("#tab4");
          };
        })(this),
        "Ctrl-4": (function(_this) {
          return function(cm) {
            return changeTab("#tab4");
          };
        })(this)
      }
    };
    this.doc = {
      altjs: new CodeMirror.Doc("console.log('hello world!');"),
      althtml: new CodeMirror.Doc("<p class='hellowolrd'>hello world!</p>"),
      altcss: new CodeMirror.Doc(".hellowolrd { color: red; }"),
      compile: new CodeMirror.Doc("")
    };
    this.currentDocName = "altjs";
    this.enableCodeMirror = true;
    this.cm = null;
    this.originDoc = null;
    this.constructCM();
    this.tab("altjs");
  }

  Editor.prototype.onsave = function() {};

  Editor.prototype.onrun = function() {};

  Editor.prototype.langToModeMap = {
    "JavaScript": "text/javascript",
    "TypeScript": "text/typescript",
    "Traceur": "text/typescript",
    "CoffeeScript": "text/x-coffeescript",
    "BlackCoffee": "text/x-coffeescript",
    "Roy": "text/x-haskell",
    "PureScript": "text/x-haskell",
    "LiveScript": "text/x-livescript",
    "GorillaScript": "text/x-livescript",
    "LispyScript": "text/x-common-lisp",
    "Wisp": "text/x-clojure",
    "BiwaScheme ": "text/x-scheme",
    "HTML": "text/html",
    "Jade": "text/x-jade",
    "CSS": "text/css",
    "Stylus": "text/css",
    "LESS": "text/x-less"
  };

  Editor.prototype.constructCM = function() {
    this.enableCodeMirror = true;
    this.cm = CodeMirror.fromTextArea(this.textarea, this.option);
    this.originDoc = this.cm.swapDoc(this.doc[this.currentDocName]);
    this.cm.setSize("100%", "100%");
    return void 0;
  };

  Editor.prototype.destructCM = function() {
    this.enableCodeMirror = false;
    this.cm.toTextArea();
    this.cm.swapDoc(this.originDoc);
    this.cm = null;
    return void 0;
  };

  Editor.prototype.get = function() {
    return {
      altjs: this.doc.altjs.getValue(),
      althtml: this.doc.althtml.getValue(),
      altcss: this.doc.altcss.getValue(),
      compile: this.doc.compile.getValue()
    };
  };

  Editor.prototype.set = function(_arg) {
    var altcss, althtml, altjs, compile;
    altjs = _arg.altjs, althtml = _arg.althtml, altcss = _arg.altcss, compile = _arg.compile;
    if (!!altjs) {
      this.doc.altjs.setValue(altjs);
    }
    if (!!althtml) {
      this.doc.althtml.setValue(althtml);
    }
    if (!!altcss) {
      this.doc.altcss.setValue(altcss);
    }
    if (!!compile) {
      this.doc.compile.setValue(compile);
    }
    this.textarea.value = this.doc[this.currentDocName].getValue();
    return void 0;
  };

  Editor.prototype.tab = function(docName) {
    if (this.config.enableCodeMirror !== this.enableCodeMirror) {
      if (this.config.enableCodeMirror) {
        this.constructCM();
      } else {
        this.destructCM();
      }
    }
    if (this.enableCodeMirror) {
      this.cm.swapDoc(this.doc[docName]);
      if (docName === "compile") {
        this.cm.setOption("mode", this.langToModeMap["HTML"]);
        this.cm.setOption("readOnly", true);
      } else {
        this.cm.setOption("mode", this.langToModeMap[this.config[docName]]);
        this.cm.setOption("readOnly", false);
      }
      setTimeout((function(_this) {
        return function() {
          return _this.cm.refresh();
        };
      })(this));
    } else {
      this.doc[this.currentDocName].setValue(this.textarea.value);
      this.textarea.value = this.doc[docName].getValue();
    }
    this.currentDocName = docName;
    return void 0;
  };

  return Editor;

})();

Sandbox = (function() {
  var stringToDataURI;

  stringToDataURI = function(data, mimetype, callback) {
    var reader;
    reader = new FileReader();
    reader.readAsDataURL(new Blob([data], {
      type: mimetype
    }));
    reader.onloadend = function() {
      return callback(null, reader.result.replace(";base64,", ";charset=utf-8;base64,"));
    };
    return reader.onerror = function(err) {
      return callback(err, "");
    };
  };

  function Sandbox(iframe, config) {
    this.iframe = iframe;
    this.config = config;
  }

  Sandbox.prototype.run = function(srcdoc) {
    var url;
    switch (this.config.iframeType) {
      case "blob":
        url = URL.createObjectURL(new Blob([srcdoc], {
          type: "text/html"
        }));
        return this.iframe.setAttribute("src", url);
      case "srcdoc":
        return this.iframe.setAttribute("srcdoc", srcdoc);
      case "base64":
        return stringToDataURI(srcdoc, "text/html", (function(_this) {
          return function(err, base64) {
            console.error(err);
            return _this.iframe.setAttribute("src", base64);
          };
        })(this));
      case "message":
        this.iframe.setAttribute("src", "https://altjsdoit.github.io/iframe.html");
        return this.iframe.onload = (function(_this) {
          return function() {
            _this.iframe.onload = null;
            return _this.iframe.contentWindow.postMessage(srcdoc, "*");
          };
        })(this);
      default:
        throw new Error("unknown iframe type: " + config.iframeType);
    }
  };

  Sandbox.prototype.stop = function() {
    this.iframe.removeAttribute("src");
    return this.iframe.removeAttribute("srcdoc");
  };

  return Sandbox;

})();

Compiler = (function() {
  var URLToArrayBuffer, URLToText, buildScripts, buildStyles, createProxyURLs, pwd;

  pwd = location.protocol + '//' + location.hostname + location.port;

  createProxyURLs = function(urls, mimetype, callback) {
    var promises;
    promises = urls.map(function(url) {
      return new Promise(function(resolve, reject) {
        return URLToArrayBuffer(url, function(err, buffer) {
          if (!!err) {
            return reject(err);
          } else {
            return resolve(URL.createObjectURL(new Blob([buffer], {
              type: mimetype
            })));
          }
        });
      });
    });
    Promise.all(promises).then(function(urls) {
      return callback(null, urls);
    })["catch"](function(err) {
      return callback(err, []);
    });
    return void 0;
  };

  URLToArrayBuffer = function(url, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(err) {
      return callback(new Error("network error"), new ArrayBuffer);
    };
    xhr.onload = function() {
      if (this.status === 200 || xhr.status === 0 && xhr.readyState === 4) {
        return callback(null, xhr.response);
      }
    };
    xhr.send();
    return void 0;
  };

  URLToText = function(url, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'text';
    xhr.onerror = function(err) {
      return callback(new Error("network error"), "");
    };
    xhr.onload = function() {
      if (this.status === 200 || xhr.status === 0 && xhr.readyState === 4) {
        return callback(null, xhr.response);
      }
    };
    xhr.send();
    return void 0;
  };

  buildScripts = function(urls) {
    return urls.map(function(url) {
      return "<script src='" + url + "'><" + "/" + "script>";
    }).join("\n");
  };

  buildStyles = function(urls) {
    return urls.map(function(url) {
      return "<link rel='stylesheet' href='" + url + "' />";
    }).join("\n");
  };

  function Compiler(config) {
    this.config = config;
    this.lang = {
      altjs: this.config.altjs,
      althtml: this.config.althtml,
      altcss: this.config.altcss
    };
    this.worker = {
      altjs: new ACC(this.lang.altjs),
      althtml: new ACC(this.lang.althtml),
      altcss: new ACC(this.lang.altcss)
    };
  }

  Compiler.prototype.change = function() {
    if (this.lang.altjs !== this.config.altjs) {
      this.lang.altjs = this.config.altjs;
      this.worker.altjs.terminate();
      this.worker.altjs = new ACC(this.lang.altjs);
    }
    if (this.lang.althtml !== this.config.althtml) {
      this.lang.althtml = this.config.althtml;
      this.worker.althtml.terminate();
      this.worker.althtml = new ACC(this.lang.althtml);
    }
    if (this.lang.altcss !== this.config.altcss) {
      this.lang.altcss = this.config.altcss;
      this.worker.altcss.terminate();
      this.worker.altcss = new ACC(this.lang.altcss);
    }
    return void 0;
  };

  Compiler.prototype.getIncludeScriptURLs = function(callback) {
    var urls;
    urls = [];
    if (this.config.enableZepto) {
      urls.push("https://altjsdoit.github.io/thirdparty/zepto/zepto.min.js");
    }
    if (this.config.enableJQuery) {
      urls.push("https://altjsdoit.github.io/thirdparty/jquery/jquery.min.js");
    }
    if (this.config.enableUnderscore) {
      urls.push("https://altjsdoit.github.io/thirdparty/underscore.js/underscore-min.js");
    }
    if (this.config.enableBackbone) {
      urls.push("https://altjsdoit.github.io/thirdparty/backbone.js/backbone-min.js");
    }
    if (this.config.enableES6shim) {
      urls.push("https://altjsdoit.github.io/thirdparty/es6-shim/es6-shim.min.js");
    }
    if (this.config.enableMathjs) {
      urls.push("https://altjsdoit.github.io/thirdparty/mathjs/math.min.js");
    }
    if (this.config.enableProcessing) {
      urls.push("https://altjsdoit.github.io/thirdparty/processing.js/processing.min.js");
    }
    if (this.config.enableChartjs) {
      urls.push("https://altjsdoit.github.io/thirdparty/Chart.js/Chart.min.js");
    }
    if (this.config.enableMathjax) {
      urls.push("https://altjsdoit.github.io/thirdparty/mathjax/MathJax.js");
    }
    if (this.config.enableBlobCache) {
      createProxyURLs(urls, "text/javascript", function(err, _urls) {
        return callback(err, buildScripts(_urls));
      });
    } else {
      setTimeout(function() {
        return callback(null, buildScripts(urls));
      });
    }
    return void 0;
  };

  Compiler.prototype.getIncludeStyleURLs = function(callback) {
    var urls;
    urls = [];
    if (this.config.enablePure) {
      urls.push("https://altjsdoit.github.io/thirdparty/pure/pure-min.css");
    }
    if (this.config.enableBlobCache) {
      createProxyURLs(urls, "text/css", function(err, _urls) {
        return callback(err, buildStyles(_urls));
      });
    } else {
      setTimeout(function() {
        return callback(null, buildStyles(urls));
      });
    }
    return void 0;
  };

  Compiler.prototype.getFirebugLiteURL = function(callback) {
    if (this.config.enableBlobCache) {
      return URLToText("https://altjsdoit.github.io/thirdparty/firebug/firebug-lite.js", function(err, text) {
        var _text;
        if (!!err) {
          callback(err, "");
        }
        _text = text.replace("var m=path&&path.match(/([^\\/]+)\\/$/)||null;", "var m=['build/', 'build']; path='" + (makeDomain(location)) + "/thirdparty/firebug/build/'");
        return callback(null, URL.createObjectURL(new Blob([_text], {
          type: "text/javascript"
        })));
      });
    } else {
      return setTimeout(function() {
        return callback(null, "https://altjsdoit.github.io/thirdparty/firebug/firebug-lite.js");
      });
    }
  };

  Compiler.prototype.compile = function(savedurl, codeObj, callback) {
    var promises;
    promises = ["altjs", "althtml", "altcss"].map((function(_this) {
      return function(key) {
        return new Promise(function(resolve, reject) {
          return _this.worker[key].compile(codeObj[key], function(err, code) {
            if (!!err) {
              return resolve([
                {
                  message: err.message,
                  stack: err.stack
                }, ""
              ]);
            }
            return resolve([err, code]);
          });
        });
      };
    })(this));
    promises.push(new Promise((function(_this) {
      return function(resolve, reject) {
        return _this.getIncludeScriptURLs(function(err, scripts) {
          if (!!err) {
            return reject(err);
          }
          return _this.getIncludeStyleURLs(function(err, styles) {
            if (!!err) {
              return reject(err);
            } else {
              return new WMURLShortener().shorten(savedurl, function(err, shortUrl) {
                if (!!err) {
                  return resolve(("<link rel='source' href='" + savedurl + "' />\n") + scripts + "\n" + styles);
                } else {
                  return resolve(("<link rel='source' href='" + shortUrl + "' />\n") + scripts + "\n" + styles);
                }
              });
            }
          });
        });
      };
    })(this)));
    Promise.all(promises).then((function(_this) {
      return function(_arg) {
        var css, cssErr, html, htmlErr, js, jsErr, link, _ref, _ref1, _ref2;
        (_ref = _arg[0], jsErr = _ref[0], js = _ref[1]), (_ref1 = _arg[1], htmlErr = _ref1[0], html = _ref1[1]), (_ref2 = _arg[2], cssErr = _ref2[0], css = _ref2[1]), link = _arg[3];
        if (!!jsErr || !!htmlErr || !!cssErr) {
          return callback(new Error("compile error"), _this.createError(jsErr, htmlErr, cssErr, null));
        } else {
          if (_this.config.enableFirebugLite) {
            return _this.getFirebugLiteURL(function(err, firebugURL) {
              if (!!err) {
                throw new Error(err);
              }
              link = "<script id='FirebugLite' FirebugLite='4' src='" + firebugURL + "'>\n{\n  overrideConsole:true,\n  showIconWhenHidden:true,\n  startOpened:true,\n  enableTrace:true\n}\n<" + "/" + "script>\n" + link;
              return callback(null, _this.createHTML(js, html, css, link));
            });
          } else {
            return callback(null, _this.createHTML(js, html, css, link));
          }
        }
      };
    })(this))["catch"]((function(_this) {
      return function(bugErr) {
        return callback(new Error("internal error"), _this.createError("", "", "", bugErr));
      };
    })(this))["catch"](function(err) {
      return console.error(err);
    });
    return void 0;
  };

  Compiler.prototype.createError = function(jsErr, htmlErr, cssErr, bugErr) {
    var report;
    report = "";
    if (!!jsErr) {
      report += this.lang.altjs + ":\n" + (jsErr.stack || jsErr.message || "compile error");
    }
    if (!!htmlErr) {
      report += this.lang.althtml + ":\n" + (htmlErr.stack || htmlErr.message || "compile error");
    }
    if (!!cssErr) {
      report += this.lang.altcss + ":\n" + (cssErr.stack || cssErr.message || "compile error");
    }
    if (!!bugErr) {
      report += "internal error" + ":\n" + (bugErr.stack || bugErr.message || "internal error");
    }
    console.error(report);
    return "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\" />\n<style>\npre{font-family: 'Source Code Pro','Menlo','Monaco','Andale Mono','lucida console','Courier New','monospace';}\n</style>\n</head>\n<body>\n<pre>\n" + report + "</pre>\n</body>\n</html>";
  };

  Compiler.prototype.createHTML = function(js, html, css, link) {
    return "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\" />\n<title>" + this.config.title + "</title>\n" + link + "\n" + css + "\n</head>\n<body>\n" + html + "\n" + js + "\n</body>\n</html>";
  };

  return Compiler;

})();

ACC = (function() {
  var createIFrameWorker, createSessionKey, createWorker;

  function ACC(name) {
    var compiler, useIframe, _ref;
    this.name = name;
    _ref = ACC.compilers[this.name], useIframe = _ref.useIframe, compiler = _ref.compiler;
    this.worker = !!useIframe ? createIFrameWorker(compiler) : createWorker(compiler);
  }

  ACC.prototype.compile = function(code, callback) {
    return this.worker.load((function(_this) {
      return function() {
        return _this.worker.request(code, callback);
      };
    })(this));
  };

  ACC.prototype.terminate = function() {
    return this.worker.terminate();
  };

  createSessionKey = function() {
    return Math.round(Math.random() * Math.pow(16, 8)).toString(16);
  };

  createIFrameWorker = function(fn) {
    var blob, iframe, loaded, url;
    blob = new Blob(["<script>(" + fn + "());<" + "/script>"], {
      type: "text/html"
    });
    url = URL.createObjectURL(blob);
    iframe = document.createElement("iframe");
    iframe.setAttribute("style", "position:absolute;top:0px;left:0px;width:0px;height:0px;border:0px;margin:0px;padding:0px;");
    iframe.setAttribute("src", url);
    loaded = false;
    iframe.onload = function() {
      return loaded = true;
    };
    document.body.appendChild(iframe);
    return {
      load: function(fn) {
        if (loaded) {
          return setTimeout(fn);
        } else {
          return setTimeout(this.load.bind(this, fn), 100);
        }
      },
      request: function(code, callback) {
        var data;
        data = {
          code: code,
          session: createSessionKey()
        };
        window.addEventListener("message", function(_arg) {
          var error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, html = _ref.html, error = _ref.error;
          window.removeEventListener("message", arguments.callee);
          if (session === data.session) {
            return callback(error, html);
          }
        });
        return iframe.contentWindow.postMessage(data, "*");
      },
      terminate: function() {
        iframe.onload = null;
        iframe.removeAttribute("src");
        return document.body.removeChild(iframe);
      }
    };
  };

  createWorker = function(fn) {
    var blob, url, worker;
    blob = new Blob(["(" + fn + "());"], {
      type: "text/javascript"
    });
    url = URL.createObjectURL(blob);
    worker = new Worker(url);
    worker.onerror = function(err) {
      console.error(err, "" + err.message + "\nat " + err.filename + ":" + err.lineno + ":" + err.colno);
      return console.info(("(" + fn + "());").slice(0, 300) + "\n...");
    };
    return {
      load: function(fn) {
        return setTimeout(fn, 0);
      },
      request: function(code, callback) {
        var data;
        data = {
          code: code,
          session: createSessionKey()
        };
        worker.postMessage(data);
        return worker.onmessage = function(_arg) {
          var error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, html = _ref.html, error = _ref.error;
          if (session === data.session) {
            return callback(error, html);
          }
        };
      },
      terminate: function() {
        return worker.terminate();
      }
    };
  };

  ACC.compilers = {
    "echoIframe": {
      "useIframe": true,
      "compiler": function() {
        return window.addEventListener("message", function(_arg) {
          var code, err, error, html, origin, session, source, srcElement, _ref;
          (_ref = _arg.data, session = _ref.session, code = _ref.code), source = _arg.source, srcElement = _arg.srcElement, origin = _arg.origin;
          try {
            html = code;
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return (source || srcElement).postMessage({
            session: session,
            html: html,
            error: error
          }, origin);
        });
      }
    },
    "echoWorker": {
      "compiler": function() {
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            html = code;
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "HTML": {
      "compiler": function() {
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            html = code;
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "Jade": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/jade/jade.min.js");
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            html = jade.compile(code, {
              pretty: true
            })({});
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "CSS": {
      "compiler": function() {
        return self.addEventListener("message", function(_arg) {
          var code, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          error = null;
          html = "<style>\n" + code + "\n</style>\n";
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "Stylus": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/stylus/stylus.min.js");
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          html = "";
          try {
            stylus.render(code, {}, function(err, css) {
              if (!!err) {
                throw new Error(err);
              }
              return html = "<style>\n" + css + "</style>\n";
            });
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "LESS": {
      "useIframe": true,
      "compiler": function() {
        document.write("<script src='https://altjsdoit.github.io/thirdparty/less.js/less.min.js'><" + "/script>\n");
        return window.addEventListener("message", function(_arg) {
          var code, err, error, html, origin, parser, session, source, srcElement, _ref;
          (_ref = _arg.data, session = _ref.session, code = _ref.code), source = _arg.source, srcElement = _arg.srcElement, origin = _arg.origin;
          html = "";
          try {
            parser = new less.Parser({});
            parser.parse(code, function(err, tree) {
              if (!!err) {
                throw new Error(err);
              }
              return html = "<style>\n" + tree.toCSS({}) + "</style>\n";
            });
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return (source || srcElement).postMessage({
            session: session,
            html: html,
            error: error
          }, origin);
        });
      }
    },
    "JavaScript": {
      "useIframe": true,
      "compiler": function() {
        document.write("<script src='https://altjsdoit.github.io/thirdparty/escodegen/esprima.js'><" + "/script>\n");
        document.write("<script src='https://altjsdoit.github.io/thirdparty/escodegen/escodegen.browser.js'><" + "/script>\n");
        return window.addEventListener("message", function(_arg) {
          var ast, code, err, error, html, js, origin, session, source, srcElement, _ref;
          (_ref = _arg.data, session = _ref.session, code = _ref.code), source = _arg.source, srcElement = _arg.srcElement, origin = _arg.origin;
          try {
            ast = esprima.parse(code, {
              raw: true,
              tokens: true,
              range: true,
              comment: true
            });
            escodegen.attachComments(ast, ast.comments, ast.tokens);
            js = escodegen.generate(ast, {
              comment: true
            });
            html = "<script>\n" + js + "\n<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return (source || srcElement).postMessage({
            session: session,
            html: html,
            error: error
          }, origin);
        });
      }
    },
    "CoffeeScript": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/coffee-script/coffee-script.min.js");
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, js, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            js = CoffeeScript.compile(code, {
              bare: true
            });
            html = "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "BlackCoffee": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/coffee-script/black-coffee-script.js");
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, js, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            js = CoffeeScript.compile(code, {
              bare: true
            });
            html = "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "LiveScript": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/livescript/livescript.min.js");
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, js, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            js = LiveScript.compile(code);
            html = "<script src='https://altjsdoit.github.io/thirdparty/livescript/prelude-browser-min.js'><" + "/script>\n";
            html += "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "GorillaScript": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/gorillascript/gorillascript.min.js");
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, js, session, _ref, _ref1;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            _ref1 = GorillaScript.compileSync(code), error = _ref1.error, js = _ref1.code;
            if (!!error) {
              throw new Error(error);
            }
            html = "<script src='https://altjsdoit.github.io/thirdparty/livescript/prelude-browser-min.js'><" + "/script>\n";
            html += "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "Roy": {
      "useIframe": true,
      "compiler": function() {
        document.write("<script src='https://altjsdoit.github.io/thirdparty/roy/roy-min.js'><" + "/script>\n");
        return window.addEventListener("message", function(_arg) {
          var code, err, error, html, js, origin, session, source, srcElement, _ref;
          (_ref = _arg.data, session = _ref.session, code = _ref.code), source = _arg.source, srcElement = _arg.srcElement, origin = _arg.origin;
          try {
            js = roy.compile(code, {}, {}, {
              modules: {
                dom: "document: {documentURI: String, getElementById: Function(String,{getAttribute: Function(String,String), innerHTML: String, innerText: String, tagName: String})}\n"
              }
            }).output;
            html = "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return (source || srcElement).postMessage({
            session: session,
            html: html,
            error: error
          }, origin);
        });
      }
    },
    "TypeScript": {
      "compiler": function() {
        self.importScripts("https://altjsdoit.github.io/thirdparty/typescript/typescript.min.js");
        return self.addEventListener("message", function(_arg) {
          var code, current, diagnostics, err, error, filename, html, iter, js, output, session, snapshot, _compiler, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            filename = "jsdo.it.ts";
            _compiler = new TypeScript.TypeScriptCompiler(filename);
            snapshot = TypeScript.ScriptSnapshot.fromString(code);
            _compiler.addFile(filename, snapshot);
            iter = _compiler.compile();
            output = '';
            while (iter.moveNext()) {
              current = iter.current().outputFiles[0];
              output += !!current ? current.text : '';
            }
            diagnostics = _compiler.getSemanticDiagnostics(filename);
            if (diagnostics.length) {
              err = diagnostics.map(function(d) {
                return d.text();
              }).join("\n");
              if (!output) {
                throw new Error(err);
              }
              console.info(err);
            }
            js = output.split("\r\n").join("\n");
            html = "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "Traceur": {
      "compiler": function() {
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            html = '<script src="https://altjsdoit.github.io/thirdparty/traceur/traceur.js"><' + '/script>\n';
            html += '<script src="https://altjsdoit.github.io/thirdparty/traceur/bootstrap.js"><' + '/script>\n';
            html += '<script>traceur.options.experimental = true;<' + '/script>\n';
            html += '<script type="module">\n';
            html += code + "\n";
            html += '<' + '/script>\n';
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "BiwaScheme": {
      "compiler": function() {
        return self.addEventListener("message", function(_arg) {
          var code, err, error, html, session, _ref;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          try {
            html = "<script src='https://altjsdoit.github.io/thirdparty/biwascheme/biwascheme-0.6.2-min.js'><" + "/script>\n";
            html += "<script id='biwa-scheme' type='text/scheme'>\n";
            html += code + "\n";
            html += "<" + "/script>\n";
            html += "<script>\n";
            html += "intp = new BiwaScheme.Interpreter();\n";
            html += "intp.evaluate(document.getElementById('biwa-scheme'));\n";
            html += "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
      }
    },
    "Wisp": {
      "useIframe": true,
      "compiler": function() {
        document.write("<script src='https://altjsdoit.github.io/thirdparty/wisp/wisp.js'><" + "/script>\n");
        return window.addEventListener("message", function(_arg) {
          var code, err, error, html, js, origin, session, source, srcElement, _ref, _ref1;
          (_ref = _arg.data, session = _ref.session, code = _ref.code), source = _arg.source, srcElement = _arg.srcElement, origin = _arg.origin;
          try {
            _ref1 = wisp.compile(code), error = _ref1.error, js = _ref1.code;
            if (!!error) {
              throw new Error(error);
            }
            js = js.replace(/\/\/\#\ssourceMappingURL\=data\:application\/json\;base64\,.+\n/, "");
            html = "<script src='https://altjsdoit.github.io/thirdparty/wisp/wisp.js'><" + "/script>\n";
            html += "<script>\n" + js + "\n<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return (source || srcElement).postMessage({
            session: session,
            html: html,
            error: error
          }, origin);
        });
      }
    },
    "LispyScript": {
      "useIframe": true,
      "compiler": function() {
        document.write("<script src='https://altjsdoit.github.io/thirdparty/lispyscript/lispyscript.js'><" + "/script>\n");
        return window.addEventListener("message", function(_arg) {
          var code, err, error, html, js, origin, session, source, srcElement, _ref;
          (_ref = _arg.data, session = _ref.session, code = _ref.code), source = _arg.source, srcElement = _arg.srcElement, origin = _arg.origin;
          try {
            js = lispyscript._compile(code);
            html = "<script>\n" + js + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return (source || srcElement).postMessage({
            session: session,
            html: html,
            error: error
          }, origin);
        });
      }
    },
    "PureScript": {
      "compiler": function() {
        var prelude, promises, wget;
        self.importScripts("https://altjsdoit.github.io/thirdparty/purescript/PureScript.browserify.js");
        self.addEventListener("message", function(_arg) {
          var code, err, error, html, result, session, _ref, _ref1;
          _ref = _arg.data, session = _ref.session, code = _ref.code;
          if (prelude.length === 0) {
            return setTimeout(Function.prototype.bind.apply(arguments.callee, [this].concat(Array.prototype.slice.call(arguments))), 0);
          }
          try {
            _ref1 = PureScript.compile({})(prelude.concat(code))(), err = _ref1.err, result = _ref1.result;
            if (!!err) {
              throw new Error(err);
            }
            html = "<script>\n" + result + "<" + "/script>\n";
          } catch (_error) {
            err = _error;
            error = {
              message: err.message,
              stack: err.stack
            };
          }
          return self.postMessage({
            session: session,
            html: html,
            error: error
          });
        });
        prelude = [];
        wget = function(url, callback) {
          var xhr;
          xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'text';
          xhr.onerror = function(err) {
            return callback(new Error("network error"), "");
          };
          xhr.onload = function() {
            if (this.status === 200 || xhr.status === 0 && xhr.readyState === 4) {
              return callback(null, xhr.response);
            }
          };
          xhr.send();
          return void 0;
        };
        promises = ["Prelude.purs", "Prelude/Unsafe.purs", "Control/Monad/Eff.purs", "Control/Monad/Eff/Unsafe.purs", "Control/Monad/ST.purs", "Data/Eq.purs", "Data/Function.purs", "Debug/Trace.purs"].map(function(path) {
          return new Promise(function(resolve, reject) {
            return wget("https://altjsdoit.github.io/thirdparty/purescript/prelude/" + path, function(err, text) {
              if (!!err) {
                return reject(err);
              } else {
                return resolve(text);
              }
            });
          });
        });
        return Promise.all(promises).then(function(_prelude) {
          return prelude = _prelude;
        })["catch"](function(err) {
          return console.log(err);
        });
      }
    }
  };

  return ACC;

})();

main();
</script>

</body>
</html>
